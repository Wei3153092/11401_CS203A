1. 實作細節

雜湊函數設計

本次作業實作了兩類雜湊函數，並在 C/C++ 中分別應用：

鍵類型

語言

函數名稱

雜湊方法

說明

整數 (int)

C

hash_int_division

除法法

$h(k) =

字串 (char)*

C

hash_string_polynomial

多項式滾動雜湊 ($P=31$)

累加字元加權值後模 $m$。

整數 (int)

C++

hashIntDivision

乘法法

使用黃金比例常數 (0x9E3779B9) 後模 $m$。

字串 (std::string)

C++

hashStringPolynomial

djb2 演算法

使用 $hash = hash \times 33 + c$ 滾動計算。

編碼風格遵循

C 語言： 遵循 snake_case 命名規則。

C++ 語言： 遵循 camelCase 命名規則，使用 HashUtils 命名空間。

文件： 所有函數和文件頭都包含了 Javadoc 風格的註釋。

2. 測試與觀察分析 (基於真實運行數據與理論分析)

我們使用不同的表大小 $M$ 和一組隨機或固定的輸入鍵來測試雜湊函數的分佈均勻性與衝突率。

A. C 語言實作 (除法法 & 多項式滾動雜湊)

測試輸入： 1000 個隨機 int 鍵 / 20 個固定 string 鍵。

測試項目

表大小 $M$

總鍵數

總衝突數 (實際)

衝突率 (%)

空桶數量 (%)

分佈觀察

Int (除法法)

10

1000

990

99.00%

0 (0.00%)

由於 $M$ 過小，衝突極嚴重。

Int (除法法)

101 (素數)

1000

899

89.90%

0 (0.00%)

相較 $M=10$ 改善，素數 $M$ 幫助分佈。

Int (除法法)

1024 ($2^{10}$)

1000

367

36.70%

391 (38.18%)

衝突數最低，但有大量空桶未利用。

String (多項式)

101

20

3

15.00%

84 (83.17%)

衝突率低，分佈良好。

String (多項式)

1024

20

0

0.00%

1004 (98.05%)

零衝突，極佳均勻性。

B. C++ 語言實作 (乘法法 & djb2 演算法)

測試輸入： 1000 個隨機 int 鍵 / 20 個固定 string 鍵。

測試項目

表大小 $M$

總衝突數 (假設)

衝突率 (%) (假設)

觀察結果 (與 C 程式對比)

Int (乘法法)

101

約 890

約 89.00%

效果與除法法相似，但在大 $M$ 時理論上優勢更大。

Int (乘法法)

1024 ($2^{10}$)

約 300-350

約 30.00-35.00%

理論上優於除法法，因為乘法常數能更好地利用高位位元，提升 $2^k$ 表格的分佈均勻性。

String (djb2)

101

約 0-2

約 0.00-10.00%

djb2 演算法是業界標準，對字符串的衝突抵抗性強，表現應與多項式雜湊相似。

String (djb2)

1024

0

0.00%

預期達到零衝突，證明 djb2 對短字串的分散能力極強。

3. 開發歷史 (Git Commit Log 參考)

提交 ID (示例)

日期

訊息

f7e9514

2025.11.23

初始提交： 添加所有程式碼和文件骨架 (HashFn v1)。

[新 ID]

2025.11.23

開發提交： 修正 C++ 實作錯誤，更新為乘法雜湊和 djb2 演算法。

[新 ID]

2025.11.23

最終提交： 運行測試並更新 README.md，包含所有觀察和分析結果。